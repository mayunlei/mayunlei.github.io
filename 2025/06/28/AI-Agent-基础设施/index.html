<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>AI Agent 基础设施 | 马云雷的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. Agent定义AI Agent是利用人工智能技术以实现特定目标并为用户完成任务的软件系统。它们展现出推理、规划、记忆以及一定程度的自主性，能够进行决策、学习和适应环境 。这些Agent能够同时处理包括文本、语音、视频、音频和代码在内的多模态信息，并具备对话、推理、学习和决策的能力 。 Agent和Workflow的区别：Workflow是把固定的流程和逻辑固化成工作流，处理流程是固定的；而A">
<meta property="og:type" content="article">
<meta property="og:title" content="AI Agent 基础设施">
<meta property="og:url" content="http://mayunlei.github.io/2025/06/28/AI-Agent-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/index.html">
<meta property="og:site_name" content="马云雷的技术博客">
<meta property="og:description" content="1. Agent定义AI Agent是利用人工智能技术以实现特定目标并为用户完成任务的软件系统。它们展现出推理、规划、记忆以及一定程度的自主性，能够进行决策、学习和适应环境 。这些Agent能够同时处理包括文本、语音、视频、音频和代码在内的多模态信息，并具备对话、推理、学习和决策的能力 。 Agent和Workflow的区别：Workflow是把固定的流程和逻辑固化成工作流，处理流程是固定的；而A">
<meta property="og:locale">
<meta property="og:image" content="https://www.madrona.com/wp-content/uploads/2025/02/UPDATED-4-21-25-Ai-Agents-Infrastructure-Stack-Feb-2025.png">
<meta property="article:published_time" content="2025-06-27T16:20:04.000Z">
<meta property="article:modified_time" content="2025-06-27T16:52:51.590Z">
<meta property="article:author" content="马云雷">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.madrona.com/wp-content/uploads/2025/02/UPDATED-4-21-25-Ai-Agents-Infrastructure-Stack-Feb-2025.png">
  
    <link rel="alternate" href="/atom.xml" title="马云雷的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">马云雷的技术博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mayunlei.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-AI-Agent-基础设施" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/28/AI-Agent-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/" class="article-date">
  <time class="dt-published" datetime="2025-06-27T16:20:04.000Z" itemprop="datePublished">2025-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      AI Agent 基础设施
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-Agent定义"><a href="#1-Agent定义" class="headerlink" title="1. Agent定义"></a>1. Agent定义</h2><p>AI Agent是利用人工智能技术以实现特定目标并为用户完成任务的软件系统。它们展现出推理、规划、记忆以及一定程度的自主性，能够进行决策、学习和适应环境 。这些Agent能够同时处理包括文本、语音、视频、音频和代码在内的多模态信息，并具备对话、推理、学习和决策的能力 。</p>
<p>Agent和Workflow的区别：Workflow是把固定的流程和逻辑固化成工作流，处理流程是固定的；而Agent则在运行时确定执行方案、调用工具、反思，具备较大的自主性。</p>
<p>理解AI Agent的这些高级能力，如自主性和复杂决策制定，对于将其与如简单的聊天机器人或基础AI助手等更简单的自动化系统区分开来至关重要。这种区分也解释了为何AI Agent需要更为复杂和精细的基础设施支持。</p>
<p>Agent的基础设施，应该覆盖Agent从研发到部署、运营等整个生命周期。</p>
<h2 id="2-AI-Agent的核心功能组件"><a href="#2-AI-Agent的核心功能组件" class="headerlink" title="2. AI Agent的核心功能组件"></a>2. AI Agent的核心功能组件</h2><p><img src="https://www.madrona.com/wp-content/uploads/2025/02/UPDATED-4-21-25-Ai-Agents-Infrastructure-Stack-Feb-2025.png" alt="img"></p>
<p>AI Agent的强大功能源于其内部多个核心组件的协同工作。这些组件共同构成了Agent的感知、思考、决策和行动能力。</p>
<h3 id="2-1-“大脑”：核心LLM、推理与规划"><a href="#2-1-“大脑”：核心LLM、推理与规划" class="headerlink" title="2.1. “大脑”：核心LLM、推理与规划"></a>2.1. “大脑”：核心LLM、推理与规划</h3><p>AI Agent的“大脑”是其智能的核心，主要由大型语言模型（LLM）、推理机制和规划模块构成。</p>
<ul>
<li>核心LLM：作为中央决策者，LLM负责执行推理、规划和语言生成等核心认知任务 。它处理输入信息，进行推断，并生成与上下文相关的输出。可以通过任务特定的提示、角色扮演模板或领域知识来配置LLM，以增强其处理特定任务的能力 。  </li>
<li>规划模块：该模块使Agent能够洞察复杂的工作流程，并生成结构化的、多步骤的计划 。这对于将复杂任务分解为可管理的小块至关重要 。常用的规划技术包括思维链（Chain of Thought, CoT）、思维树（Tree of Thought, ToT）和ReAct（Reasoning and Act）。这些技术赋予Agent处理模糊性、迭代解决方案和动态调整策略的能力 。规划能力对于Agent识别必要步骤、评估潜在行动，并根据可用信息和期望结果选择最佳行动方案至关重要 。</li>
</ul>
<h3 id="2-2-感知与行动模块：与环境交互"><a href="#2-2-感知与行动模块：与环境交互" class="headerlink" title="2.2. 感知与行动模块：与环境交互"></a>2.2. 感知与行动模块：与环境交互</h3><p>为了使Agent不仅仅停留在对话层面，它需要感知其所处的数字或物理环境，并据此采取行动。感知和行动模块即是Agent的“感官”和“效应器”。</p>
<ul>
<li>环境感知模块：感知模块负载把需要的上下文、环境信息召回，传递给大模型。在感知模块中，语义搜索、NL2SQL等能力是基础，这些模块的能力把LLM感知环境的需求转换为具体的获取数据的操作。  </li>
<li>行动模块 ：负责执行Agent的决策，这可能包括调用API、与外部工具交互、生成文本或代码，甚至在机器人技术中执行物理动作。</li>
</ul>
<p>环境感知是至关重要的。LLM只负责推理，而针对的场景要有环境感知模块决定。如果获取的数据不对，那么LLM也很难给出完美的答案。</p>
<h3 id="2-3-Memory：学习与维护上下文"><a href="#2-3-Memory：学习与维护上下文" class="headerlink" title="2.3. Memory：学习与维护上下文"></a>2.3. Memory：学习与维护上下文</h3><p>Memory将LLM从一个无状态的处理器转变为一个能够学习和适应的Agent。强大的记忆能力对于Agent的连续性、连贯性、从过去的交互中学习以及通过回忆历史交互和适应新情况来提高性能至关重要 。LLM缺乏个性化，而记忆系统充分提取个性化特征，是的LLM可以根据个性化特征给与个性化回复。</p>
<p>在Memory中又分为长期记忆和短期记忆：</p>
<ul>
<li>短期记忆 (Short-Term Memory)：<ul>
<li>通常在LLM的上下文窗口内处理，用于支持轮次间的对话和即时回忆 。它能够维持会话内的上下文 。  </li>
<li>对于需要在多次交流中保持上下文的对话式AI非常有用 。  </li>
<li>由于上下文受限，在短期记忆中，如果把全部的会话记录都保存下来，会导致LLM失去重点，产生幻觉。因而更好的方式是对短期记忆进行不断地总结、归纳，提取出需要的信息。因而在短期记忆中，总结能力是必须的。而召回能力则不是。</li>
</ul>
</li>
<li>长期记忆 (Long-Term Memory)：<ul>
<li>涉及对交互历史、事实或学习到的行为进行持久化存储，通常使用向量数据库（如FAISS、Pinecone）或知识图谱来实现 。  </li>
<li>使Agent能够从过去学习，提取洞察以改进未来的会话 。以及提供个性化的能力。</li>
<li>LTM的类型包括 ：  <ul>
<li>情景记忆 (Episodic Memory)：回忆特定的过去经历或事件。通过记录关键事件、行动及其结果来实现。</li>
<li>语义记忆 (Semantic Memory)：存储结构化的事实知识（如事实、定义、规则）。通过知识库、符号AI或向量嵌入来实现。</li>
<li>程序记忆 (Procedural Memory)：存储和回忆技能、规则和学习到的行为，以便自动执行任务。通常通过强化学习获得。</li>
</ul>
</li>
<li>检索增强生成（Retrieval-Augmented Generation, RAG）技术能够从LTM中动态获取和整合相关知识 。</li>
</ul>
</li>
<li>分层记忆系统：如工作记忆、短期记忆和长期记忆的组合，可以提高检索速度和上下文保真度 。</li>
</ul>
<p>短期记忆和长期记忆之间的区别，以及各种长期记忆类型，凸显了强大记忆基础设施所需的复杂性。向量数据库是实现有效长期记忆的关键赋能技术。</p>
<h3 id="2-4-工具集成与使用：扩展Agent能力"><a href="#2-4-工具集成与使用：扩展Agent能力" class="headerlink" title="2.4. 工具集成与使用：扩展Agent能力"></a>2.4. 工具集成与使用：扩展Agent能力</h3><p>LLM本身受限于其训练数据。工具为Agent提供了访问实时信息、外部系统和专业功能的途径，从而极大地扩展了Agent的实际应用能力。</p>
<p>工具的使用将一个被动的LLM转变为一个能够执行现实世界任务的主动Agent 。这些工具使LLM Agent能够与外部环境（如维基百科搜索API、代码解释器、数学引擎）、数据库、知识库和外部模型进行交互 。集成点包括Web搜索和摘要API、数据库查询（SQL生成器）、代码执行引擎以及各种第三方服务 。  </p>
<p>在工具中，涉及到的内容包括：</p>
<ul>
<li><p>交互协议层：</p>
<ul>
<li><p>MCP协议：LLM 和工具之间的标准化交互协议。</p>
</li>
<li><p>A2A协议：Agent2Agent的交互协议。</p>
</li>
</ul>
</li>
<li><p>浏览器工具：browser-use是一个很重要的tool，用于Agent浏览和操作网页中的内容，浏览器工具允许Agent不仅仅通过API访问环境和操作环境。Browserbase, Lightpanda, and Browserless 这些公司在构建浏览器工具的基础设施。</p>
</li>
<li><p>工具发现和整合：全网那么多的MCP工具，怎么找到合适的工具是一个难题，这催生了工具发现类的服务。</p>
</li>
<li><p>沙箱：沙箱是保障工具安全运行的前提。除了调用外部工具存在安全性的担忧，对LLM on-demand生成的工具也存在类似担忧。在未来，大部分的工具应该是由LLM按需生成的。在沙箱内运行这些工具，可以避免一些安全性问题。有一些公司提供沙箱内的服务，比如E2B。</p>
</li>
<li><p>Agent as a Service：一些公司，提供tool类的服务。例如：</p>
<ul>
<li>搜索类：搜索应该是一些场景的基础，例如问答类机器人。搜索相关的上下文可以提升信息的时效性，提供更加准确的信息。例如tavily，提供了搜索的API。</li>
<li>数据爬取：爬虫或者数据类产品，例如Firecrawl 是一款 可以将网站转换为 Markdown 格式的爬虫工具 ，主要 提供 API 服务 ，无需站点地图，只需要接收一个 URL 地址就可以爬取网站及网站下可访问的所有子页面内容。</li>
<li>UI-Automation：操作浏览器类工具。</li>
<li>支付类工具：提供支付服务。</li>
</ul>
</li>
</ul>
<h3 id="2-5-路由器-控制器：管理复杂工作流"><a href="#2-5-路由器-控制器：管理复杂工作流" class="headerlink" title="2.5. 路由器&#x2F;控制器：管理复杂工作流"></a>2.5. 路由器&#x2F;控制器：管理复杂工作流</h3><p>随着Agent处理日益复杂、涉及多个工具或子Agent的多步骤任务，一个有效的控制器对于协调这些组件变得至关重要。</p>
<p>在复杂的Agent中，路由机制根据任务需求决定调用哪个工具或子流程 。这个控制器管理动态工作流，并在推理、记忆检索和工具执行之间进行协调，确保Agent能够根据实时情况做出适当响应 。  </p>
<p>AI Agent的核心功能模块——大脑（LLM、推理与规划）、感知与行动、记忆、工具和控制器——并非简单相加，而是高度相互依赖。任何一个环节的薄弱都会显著削弱整体的“智能代理”能力。例如，一个拥有强大LLM但记忆系统欠佳的Agent无法有效学习或维持上下文。一个规划能力出色但缺乏工具的Agent则无法与外部世界互动。因此，Agent基础设施的设计需要采取整体方法，确保每个组件不仅自身强大，而且能与其他组件无缝高效集成。工具的多样性、可靠性和可访问性是决定Agent解决广泛现实世界问题能力的主要因素。基础设施不仅要允许工具使用，更要促进广泛且可扩展工具集的轻松集成、管理和安全调用。同样，记忆系统的复杂程度（如短期记忆、长期记忆类型、检索机制）对Agent学习、长期适应和提供个性化体验的能力至关重要。基础设施必须支持多种信息类型的有效编码、强大的检索机制（如基于向量数据库的RAG）以及潜在的分层结构，以有效管理不同范围的记忆。</p>
<h2 id="3-Agent系统运维基础设施"><a href="#3-Agent系统运维基础设施" class="headerlink" title="3. Agent系统运维基础设施"></a>3. Agent系统运维基础设施</h2><p>为了确保AI Agent系统在实际应用中的高效、稳定和安全运行，一套关键的运维基础设施必不可少。这包括LLM API网关、缓存策略以及安全的工具执行环境。</p>
<h3 id="3-1-LLM-API网关：统一访问、安全与可观测性"><a href="#3-1-LLM-API网关：统一访问、安全与可观测性" class="headerlink" title="3.1. LLM API网关：统一访问、安全与可观测性"></a>3.1. LLM API网关：统一访问、安全与可观测性</h3><p>随着企业越来越多地使用多个LLM或微调模型，以及提供企业内的服务，LLM API网关成为管理访问、确保安全、优化性能和控制成本的关键组件。它将底层模型的复杂性从应用开发者那里抽象出来。</p>
<p>LLM网关充当访问多个LLM提供商或自托管模型的集中接口，提供统一的API 。它简化了处理特定模型API、速率限制、重试机制和基础设施差异的复杂性 。其核心功能包括 ：  </p>
<ul>
<li>统一访问：为各种LLM提供单一入口点。</li>
<li>安全与合规：管理身份验证（如集中密钥管理、基于角色的访问控制RBAC）和数据治理。</li>
<li>审计：记录访问LLM的内容。在无法获得LLM侧的访问日志的前提下，在网关侧记录日志有利于审计。</li>
<li>性能优化：跨模型&#x2F;提供商进行负载均衡，并实现响应缓存。</li>
<li>路由与回退：当主模型出现问题时自动切换到备用模型，并对瞬时错误进行自动重试。</li>
<li>速率限制：管理请求量以防止过载并控制成本。</li>
<li>可观测性：提供性能监控（如延迟、错误率）、使用情况分析（如Token使用量）和成本管理功能。</li>
<li>内部分账：不同部分访问同一个LLM账号，而网关则用于区分不同的内部账号。</li>
</ul>
<h3 id="3-2-LLM响应的缓存策略：性能与成本优化"><a href="#3-2-LLM响应的缓存策略：性能与成本优化" class="headerlink" title="3.2. LLM响应的缓存策略：性能与成本优化"></a>3.2. LLM响应的缓存策略：性能与成本优化</h3><p>LLM的推理过程可能既缓慢又昂贵。有效的缓存对于构建响应迅速且经济高效的Agent应用至关重要，尤其适用于处理常见问题或重复任务的场景。</p>
<p>LLM缓存通过存储和重用先前计算的LLM响应来减少延迟和计算成本 。主要的缓存策略包括：  </p>
<ul>
<li>精确键缓存 (Exact Key Caching)：为特定、完全相同的输入查询存储响应。这种方法检索速度快，实现简单，但对输入的微小变化（如多余空格或拼写错误）非常敏感 。  </li>
<li>语义缓存 (Semantic Caching)：根据输入内容的语义相似性来存储和检索响应。这种方法能够处理措辞不同但含义相同的查询，从而提高缓存命中率，但存在因语义相似而导致错误匹配（即“假阳性”）的潜在风险 。</li>
</ul>
<p>缓存设计模式包括单层LLM缓存、多层缓存（例如，第一层精确匹配，第二层语义匹配）以及基于RAG的缓存（预检索文档缓存和后检索响应缓存）。有效的缓存管理还涉及可配置的缓存过期策略、缓存失效机制、优化缓存命中率以及平衡缓存大小与内存使用（例如，使用最近最少使用LRU淘汰策略）。缓存的典型用例包括客户支持机器人（处理高频查询）、搜索引擎（缓存常用搜索词）、推荐系统和内容生成应用 。  </p>
<p>对于交互式Agent，尤其是在对话或执行实时任务时，低延迟对于用户满意度和感知智能至关重要。语义缓存能够处理措辞变化的查询，显著提高了缓存命中率，这意味着更多用户请求可以从缓存中快速得到服务，从而减轻了对LLM的负载。因此，复杂的、可能是多层次的、并利用语义理解的缓存策略，是构建高性能、可扩展的Agent系统的重要基础设施组成部分。</p>
<h3 id="3-3-安全的工具执行环境：沙箱与凭证管理"><a href="#3-3-安全的工具执行环境：沙箱与凭证管理" class="headerlink" title="3.3. 安全的工具执行环境：沙箱与凭证管理"></a>3.3. 安全的工具执行环境：沙箱与凭证管理</h3><p>如果Agent能够执行代码或通过API与外部工具交互，确保这一过程的安全性至关重要。Agent自主性的增加，特别是在使用工具（如执行代码）时，会引入重大的安全风险，例如任意代码执行 。  </p>
<p>沙箱 (Sandboxing) 对于管理资源和创建安全的执行环境至关重要，它可以封装潜在的有害代码，防止其影响更广泛的系统 。 </p>
<h2 id="4-Agent编排与协作"><a href="#4-Agent编排与协作" class="headerlink" title="4. Agent编排与协作"></a>4. Agent编排与协作</h2><p>Agent的智能不仅仅体现在其个体能力上，更在于它们如何组织自己的“思维”过程以及如何与其他Agent或系统进行协作。编排模式和系统架构的选择对Agent的整体效能有深远影响。</p>
<h3 id="4-1-关键编排模式：构建Agent思维与行动"><a href="#4-1-关键编排模式：构建Agent思维与行动" class="headerlink" title="4.1. 关键编排模式：构建Agent思维与行动"></a>4.1. 关键编排模式：构建Agent思维与行动</h3><p>编排模式为Agent（或其LLM大脑）如何处理问题、制定决策以及与工具互动提供了框架。选择合适的模式会影响Agent的能力、复杂性和可解释性。</p>
<ul>
<li>思维链 (Chain-of-Thought, CoT)：将任务分解为更小的步骤，以逐步求解。非常适合需要逻辑或多步骤推理的任务 。它帮助模型分解任务，使其思考过程更易于理解 。 </li>
<li>ReAct (Reasoning and Acting, 推理与行动)：将CoT推理与外部工具使用相结合 。它涉及一个“思考 (Thought) -&gt; 行动 (Action) -&gt; 观察 (Observation)”的循环 。这使得Agent能够根据新信息或前一步骤的结果动态调整其方法 ，从而增强LLM在Agent工作流中处理复杂任务和决策的能力 。  </li>
<li>Reflexion (反思)：利用反馈循环，使LLM能够反思过去的输出并迭代地改进其性能 。这种模式非常适用于需要多次尝试进行优化和复杂推理的任务 。</li>
</ul>
<h3 id="4-2-单Agent与多Agent系统架构"><a href="#4-2-单Agent与多Agent系统架构" class="headerlink" title="4.2. 单Agent与多Agent系统架构"></a>4.2. 单Agent与多Agent系统架构</h3><p>问题的复杂性往往决定了是单个高能力的Agent足够，还是一个由专业化、协作的Agent组成的团队更为有效。这一选择对通信和协调基础设施有重大影响。</p>
<ul>
<li>单Agent系统：最适合需要快速执行且无需协调或协作的任务 。  </li>
<li>多Agent系统 (MAS)：适用于动态的、多层面的环境，其中专业化和协调至关重要 。在MAS中，可以为Agent分配专门的角色并让它们协同工作 。多Agent工作流为僵化的基于规则的自动化提供了一种灵活的、自然语言驱动的替代方案 。Agent之间可以协作、辩论想法、相互学习，从而做出更好的决策 。  </li>
<li>MAS的挑战：协调复杂性、性能可变性、可扩展性、资源管理是MAS面临的主要挑战 。有效的通信渠道设计本身就很复杂 。</li>
</ul>
<p>从单Agent系统转向多Agent系统不仅仅是数量上的扩展，更是一种质的转变，引入了Agent间通信、协调和信任等挑战，这些都需要专门的基础设施组件来支持。单个Agent主要进行内部推理，而多个Agent则必须有效沟通，可能还需要协商、解决冲突，并维持共享的态势感知或目标。这意味着MAS基础设施需要的不仅仅是单个Agent的执行环境，还需要强大的Agent间通信协议（例如，支持双向通信 ）、共享内存或“黑板”系统 、角色管理，以及可能更高级别的编排器或“管理Agent”（如CrewAI的层级化流程 ）。MAS的“社会”动态意味着基础设施不仅要支持计算，还要支持协作。</p>
<h2 id="5-开发、部署与管理"><a href="#5-开发、部署与管理" class="headerlink" title="5. 开发、部署与管理"></a>5. 开发、部署与管理</h2><p>构建、部署和有效管理AI Agent系统，需要依赖于合适的开发框架、遵循LLMOps的最佳实践，并对基础设施的构建与购买做出战略性决策。</p>
<h3 id="5-1-开源Agent框架概述"><a href="#5-1-开源Agent框架概述" class="headerlink" title="5.1. 开源Agent框架概述"></a>5.1. 开源Agent框架概述</h3><p>开源Agent框架旨在通过提供预构建的组件和抽象来简化Agent的开发过程。了解它们的理念、优势和劣势是选择合适工具或决定采用自定义方法的关键。</p>
<ul>
<li>LangChain：采用模块化架构，适用于具有直接工作流的简单Agent。它支持向量数据库和记忆功能，其LangSmith平台可用于调试和监控 。然而，一些开发者认为它过度抽象，难以使用，甚至有些过度工程化 。  </li>
<li>LangGraph：作为LangChain生态系统的一部分，LangGraph采用图架构（节点代表任务&#x2F;动作，边代表转换），并包含一个状态组件来维护任务列表。它非常适合周期性、条件性或非线性工作流 。LangGraph提供了比其他框架更高的可控性，并有意保持其底层和集成无关性 。  </li>
<li>AutoGen：由微软推出的多Agent AI框架，采用分层架构（核心层、AgentChat层、扩展层）。它支持异步消息传递和对话式AI助手的构建，并提供AutoGen Bench和AutoGen Studio用于开发和基准测试 。  </li>
<li>CrewAI：一个用于多Agent解决方案的编排框架，采用基于角色的架构（Agent、任务、流程——顺序或分层）。它底层使用了LangChain ，但本身是一个独立的框架 。其局限性在于目前主要支持顺序编排，并且可能产生不完整的输出 。  </li>
<li>LlamaIndex：一个全面的LLM应用开发框架，在RAG（检索增强生成）方面表现出色。它提供统一API、文本处理工具，并针对性能进行了优化 。其主要模块包括  <code>llama-index-core</code>、<code>llama-index-integrations</code>和<code>llama-index-packs</code> 。适用场景包括聊天机器人、内容生成、数据提取&#x2F;分析和代码辅助 ，尤其适用于涉及大型图谱、多样化检索和资源效率的RAG应用 。但也有用户认为它不必要、复杂，且底层代码难以阅读 。</li>
</ul>
<p>在开源Agent框架中，其主要作用是负责Agent逻辑的编排，而过度封装则导致使用复杂。Langgraph是这比较符合Agent工程的框架。</p>
<h3 id="5-2-Agent系统的LLMOps：生命周期管理"><a href="#5-2-Agent系统的LLMOps：生命周期管理" class="headerlink" title="5.2. Agent系统的LLMOps：生命周期管理"></a>5.2. Agent系统的LLMOps：生命周期管理</h3><p>随着Agent从原型走向生产环境，系统化的LLMOps方法对于确保其可靠性、可扩展性和持续改进至关重要。Agent系统因其推理、规划和工具使用能力，为传统的MLOps带来了新的复杂性。</p>
<p>LLMOps的定义与重要性：LLMOps是指在LLM的整个生命周期中对其进行管理，包括开发、测试、部署、监控和优化 。它是MLOps的一个专门子集，专注于生成式AI模型 。LLMOps之所以重要，是因为它有助于避免诸如错误答案、安全漏洞和模型性能下降等风险，确保模型输出的一致性和高性能 。  </p>
<p>针对Agent的关键LLMOps实践 ：  </p>
<ul>
<li>组件版本控制与组合性：跟踪Agent模块（大脑、记忆、工具等）的变更，并允许轻松替换。</li>
<li>可观测性与可调试性：能够检查决策树、推理链和行动日志。像Weave这样的工具可用于追踪。</li>
<li>CI&#x2F;CD集成：验证变更不会导致功能退化。</li>
<li>提示版本控制与测试流水线：跟踪提示的变更及其产生的效果。</li>
<li>工具注册表：管理外部API、数据库和插件。</li>
<li>安全过滤器与约束：确保Agent在定义的边界内行动，例如使用Guardrails监控安全性和偏见。</li>
</ul>
<p>Agent的评估与监控 ：  </p>
<ul>
<li>Agent的行为是动态且不确定的。评估需要覆盖多步骤工作流和决策树，而不仅仅是单个提示的完成情况。</li>
<li>使用自动化评估工作流，结合定量指标（如困惑度、BLEU分数）和定性指标（如人工反馈、幻觉率）。  </li>
<li>监控模型的漂移、幻觉、延迟和偏见 。  </li>
<li>采用A&#x2F;B测试和影子部署等方法评估变更效果 。</li>
</ul>
<p>Agent评估是比较重要的基建，甚至比其他内容还要重要，因为其他内容是可以由LLM自动生成出来的。而评估，则是要有用户制定粗来评估内容，以符合用户的目标。在一些产品中，例如Databricks的AgentBrick，采用评估驱动的方式自动生成Agent。用户定义好目标和评估指标，服务自动生成满足要求的Agent</p>
<h2 id="6-企业应用与架构考量"><a href="#6-企业应用与架构考量" class="headerlink" title="6. 企业应用与架构考量"></a>6. 企业应用与架构考量</h2><p>将AI Agent应用于企业实际业务场景，不仅能带来显著效益，也对现有IT架构提出了新的挑战。理解这些应用和挑战，对于成功部署和扩展Agent系统至关重要。</p>
<h3 id="6-1-真实世界的企业用例"><a href="#6-1-真实世界的企业用例" class="headerlink" title="6.1. 真实世界的企业用例"></a>6.1. 真实世界的企业用例</h3><p>通过具体的用例可以更好地理解Agent基础设施在实际应用中的价值和需求。</p>
<ul>
<li>文档智能与合规</li>
<li>客户支持与会员服务</li>
<li>财务与采购</li>
<li>降本体校</li>
</ul>
<h3 id="6-2-企业规模化采用的架构挑战"><a href="#6-2-企业规模化采用的架构挑战" class="headerlink" title="6.2. 企业规模化采用的架构挑战"></a>6.2. 企业规模化采用的架构挑战</h3><p>将AI Agent从试点项目推广到企业范围的部署，会暴露出一些重大的架构和运营挑战，这些挑战必须通过相应的基础设施来解决。</p>
<ul>
<li>指令过载&#x2F;提示工程：过度依赖自然语言提示会导致指令臃肿、不一致、难以扩展且难以调试。企业需要模块化的Agent配置框架，包括声明式目标、防护栏、工具模式和可复用的指令块。  </li>
<li>规划能力不足：将用户模糊的请求转化为精确、可分解的任务计划是一个主要障碍。当前的Agent在被明确告知任务后执行良好，但在初始解读和规划方面能力较弱。这需要强大的规划Agent或规划模块，能够理解意图，访问知识图谱或工作流本体，分解任务并进行路由。  </li>
<li>Agent间的通信原始：目前主要通过传递自然语言输出作为彼此输入的方式进行通信，这种方式较为原始，易导致结构丢失、错误级联和审计困难。企业需要类型化的、结构化的、基于契约的通信机制（如JSON、事件模式、共享内存&#x2F;黑板）。多向通信也可能存在问题 。  </li>
<li>治理、可审计性与安全性：  <ul>
<li>缺乏信任框架：安全部门在没有审计追踪、回退机制和工具使用防护栏的情况下，对批准自主Agent持谨慎态度 。 </li>
<li>需要为Agent实施基于角色的访问控制、可追踪的推理链、综合监控和异常检测机制 。这些不仅仅是Agent本身的特性，更是由周边基础设施（如日志系统、Agent的身份和访问管理系统、能够解读Agent决策路径的监控工具）启用和强制执行的系统属性。</li>
</ul>
</li>
<li>可扩展性与性能瓶颈 ：编排大量Agent会带来性能挑战。传统的云扩展模型可能会发生转变，因为Agent AI对某些任务的集中处理需求可能较低 。  </li>
<li>互操作性：与多样化的数据源、API和遗留系统交互需要周密的规划。</li>
</ul>
<h2 id="7-Agent基础设施的挑战与未来方向"><a href="#7-Agent基础设施的挑战与未来方向" class="headerlink" title="7. Agent基础设施的挑战与未来方向"></a>7. Agent基础设施的挑战与未来方向</h2><p>AI Agent基础设施领域正经历快速发展，同时也面临着诸多技术挑战。洞察这些挑战并把握新兴趋势，对于规划和构建面向未来的Agent系统至关重要。</p>
<h3 id="7-1-当前技术挑战"><a href="#7-1-当前技术挑战" class="headerlink" title="7.1. 当前技术挑战"></a>7.1. 当前技术挑战</h3><p>尽管AI Agent展现出巨大潜力，但其基础设施仍面临一些亟待解决的技术难题：</p>
<ul>
<li>长期规划难题：在处理较长步骤的问题时，大模型可能会出现幻觉，错误的理解任务，或者陷入某种死循环操作。</li>
<li>有限上下文长度 ：大模型的上下文长度有限，需要把关键的数据作为上下文。</li>
<li>理解人类意图：使Agent完全理解人类的意图存在困难，在细节处理上自作主张，导致出现偏差。  </li>
<li>提示的鲁棒性与可靠性：LLM Agent通常依赖多个提示，即使对提示进行微小改动也可能引发问题。它们容易产生幻觉，尤其是在从外部组件获取到冲突信息时。  因而对prompt的任何改动都需要回测。</li>
<li>知识边界：控制LLM的知识范围非常困难；其内部知识可能在特定环境中引入偏见或影响Agent的行为。  </li>
<li>效率与成本：大量的LLM请求会影响Agent的行动效率（这在很大程度上取决于LLM的推理速度）。部署多个Agent时的成本也是一个需要关注的问题。  </li>
<li>多Agent系统的协调复杂性 ：随着系统规模的扩大，协调难度呈指数级增长。时序问题可能导致任务失败。  </li>
<li>MAS的性能稳定性：环境变化、Agent能力差异、网络延迟以及复杂交互产生的突现行为，都可能导致系统结果的不可预测性。  </li>
<li>MAS的可扩展性与资源管理：增加Agent数量有时可能导致收益递减甚至系统崩溃。资源分配尤为棘手。</li>
</ul>
<h3 id="7-2-新兴趋势"><a href="#7-2-新兴趋势" class="headerlink" title="7.2. 新兴趋势"></a>7.2. 新兴趋势</h3><p>展望未来，Agent基础设施正朝着更智能、更协同、更可信的方向发展：</p>
<ul>
<li>增强的推理能力与LLM集成：更先进的LLM正在提升Agent的理解力、上下文感知能力，使其能够处理复杂的多轮对话并支持高风险决策。  </li>
<li>用于自我改进的强化学习：Agent能够通过强化学习在动态环境中自我学习并优化决策（例如，在自主交易系统中）。  </li>
<li>多环境操作：未来的自主Agent将能够无缝地在虚拟平台和物理操作之间转换（例如，在物流领域同时管理仓库自动化和在线库存系统）。  </li>
<li>群体智能&#x2F;高级多Agent协作：多个Agent协同工作，共享数据和决策，以集体解决复杂问题。AI技术将更深入地集成以改善协调。  </li>
<li>个性化与定制化：通过行为分析和上下文学习，提供更量身定制的体验。  </li>
<li>结构化的Agent开发环境：类似于“Agent的VSCode”，提供集成工具、模拟、测试和版本控制功能。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mayunlei.github.io/2025/06/28/AI-Agent-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/" data-id="cmcf1wffc0002mz3j3ju9dsfy" data-title="AI Agent 基础设施" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/28/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/2024/10/13/c-11-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%8E%B0%E4%BB%A3%E5%8C%96%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%9F%E5%BA%A6%E7%A7%98%E8%AF%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">c++11+模板元编程：现代化计算引擎的速度秘诀</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ClickHouse-OLAP/" rel="tag">ClickHouse OLAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ML-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="tag">ML 机器学习 神经网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E6%B4%9E%E5%AF%9F/" rel="tag">SQL洞察</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/presto/" rel="tag">presto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/string-cow/" rel="tag">string cow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%91%E9%87%8F%E5%8C%96-SIMD/" rel="tag">向量化, SIMD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ClickHouse-OLAP/" style="font-size: 10px;">ClickHouse OLAP</a> <a href="/tags/ML-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">ML 机器学习 神经网络</a> <a href="/tags/SQL%E6%B4%9E%E5%AF%9F/" style="font-size: 10px;">SQL洞察</a> <a href="/tags/presto/" style="font-size: 20px;">presto</a> <a href="/tags/string-cow/" style="font-size: 10px;">string cow</a> <a href="/tags/%E5%90%91%E9%87%8F%E5%8C%96-SIMD/" style="font-size: 10px;">向量化, SIMD</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/28/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/06/28/AI-Agent-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/">AI Agent 基础设施</a>
          </li>
        
          <li>
            <a href="/2024/10/13/c-11-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%8E%B0%E4%BB%A3%E5%8C%96%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%9F%E5%BA%A6%E7%A7%98%E8%AF%80/">c++11+模板元编程：现代化计算引擎的速度秘诀</a>
          </li>
        
          <li>
            <a href="/2024/03/03/OLAP%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/">OLAP计算引擎原理和实现</a>
          </li>
        
          <li>
            <a href="/2022/06/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%90%91%E9%87%8F%E5%8C%96%E6%8A%80%E6%9C%AF/">深入向量化计算技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 马云雷<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>